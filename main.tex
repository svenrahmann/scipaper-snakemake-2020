\documentclass[parskip=half, DIV=18]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{authblk}
\PassOptionsToPackage{hyphens}{url}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\lstset{basicstyle=\ttfamily}
\usepackage{enumitem}
\setlist[enumerate]{itemsep=0mm}
\setlist[itemize]{itemsep=0mm}

% Cross referencing external documents.
\usepackage{xr}
% Command for registering file dependencies with latexmk.
\makeatletter
\newcommand*{\addFileDependency}[1]{% argument=file name and extension
  \typeout{(#1)}
  \@addtofilelist{#1}
  \IfFileExists{#1}{}{\typeout{No file #1.}}
}
\makeatother

\externaldocument[s-]{supplement}
\addFileDependency{supplement.tex}
\addFileDependency{supplement.aux}

\usepackage[maxbibnames=999,backend=bibtex,url=false,doi=true,isbn=true]{biblatex}
\addbibresource{literature.bib}

\newcommand{\sharedfirst}{$\dagger$}
\newcommand{\sharedfirsttext}[1]{\affil[\sharedfirst]{#1}}
\newcommand{\corresponding}{*}
\newcommand{\correspondingtext}[1]{\affil[\corresponding]{#1}}
\newcommand{\image}[1]{\centering\includegraphics[width=\textwidth]{#1}}
\let\plainurl\url
\renewcommand{\url}[1]{\protect\plainurl{#1}}

\begin{document}

\author[1,2]{Felix Mölder}
\author[6,15]{Kim Philipp Jablonski}
\author[4]{Brice Letcher}
\author[4]{Michael B. Hall}
\author[11,16]{Christopher H. Tomkins-Tinch}
\author[5]{Vanessa Sochat}
\author[1]{Jan Forster}
\author[3]{Soohyun Lee}
\author[8]{Sven~O.~Twardziok}
\author[9]{Alexander Kanitz}
\author[14]{Andreas Wilm}
\author[10,8]{Manuel Holtgrewe}
\author[17]{Sven Rahmann}
\author[12]{Sven Nahnsen}
\author[1,7,\corresponding]{Johannes Köster}

\affil[1]{Algorithms for reproducible bioinformatics, Genome Informatics, Institute of Human Genetics, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\affil[2]{Institute of Pathology, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\affil[3]{Biomedical Informatics, Harvard Medical School, Harvard University, Boston, USA}
\affil[4]{EMBL-EBI, Hinxton, UK}
\affil[5]{Stanford University Research Computing Center, Stanford University}
\affil[6]{Department of Biosystems Science and Engineering, ETH Zurich, Basel, Switzerland}
\affil[7]{Medical Oncology, Harvard Medical School, Harvard University, Boston, USA}
\affil[8]{Charité - Universitätsmedizin Berlin, corporate member of Freie Universität Berlin, Humboldt-Universität zu Berlin, and Berlin Institute of Health (BIH), Center for Digital Health, Berlin, Germany}
\affil[9]{Biozentrum, University of Basel, Switzerland \& SIB Swiss Institute of Bioinformatics / ELIXIR Switzerland, Lausanne, Switzerland}
\affil[10]{CUBI – Core Unit Bioinformatics, Berlin Institute of Health, Berlin, Germany}
\affil[11]{Broad Institute of MIT and Harvard, Cambridge, USA}
\affil[12]{Quantitative Biology Center (QBiC), University of Tübingen, Tübingen, Germany}
\affil[14]{Microsoft Singapore, Singapore}
\affil[15]{Swiss Institute of Bioinformatics (SIB), Basel, Switzerland}
\affil[16]{Department of Organismic and Evolutionary Biology, Harvard University, Cambridge, MA, USA}
\affil[17]{Genome Informatics, Institute of Human Genetics, University Hospital Essen, University of Duisburg-Essen, Essen, Germany}
\correspondingtext{To whom correspondence should be addressed}

\title{Sustainable data analysis with Snakemake}
\maketitle

\begin{abstract}
	Data analysis often entails a multitude of heterogeneous steps, from the application of various command line tools to the usage of scripting languages like R or Python for the generation of plots and tables.
	It is widely recognized that data analyses should ideally be conducted in a reproducible way.
	Reproducibility enables technical validation and regeneration of results on the original or even new data.
	However, reproducibility alone is by no means sufficient to deliver an analysis that is of lasting impact (i.e., sustainable) for the field, or even just one research group.
	We postulate that it is equally important to ensure adaptability and transparency.
	The former describes the ability to modify the analysis to answer extended or slightly different research questions.
	The latter describes the ability to understand the analysis in order to judge whether it is not only technically, but methodologically valid.

	Here, we analyze the properties needed for a data analysis to become reproducible, adaptable, and transparent, and show how the popular workflow management system Snakemake can be used to guarantee this.
\end{abstract}

\section{Introduction}\label{sec:introduction}

Despite the ubiquity of data analysis across scientific disciplines, it is a challenge to ensure \emph{in silico} reproducibility~\parencite{Mesirov2010,Baker2016,Munaf__2017}.
By automating the analysis process, workflow management systems can help to achieve such reproducibility.
Consequently, a ``Cambrian explosion'' of diverse scientific workflow management systems is in process; some are already in use by many and evolving, and countless others are emerging and being published (see~\url{https://github.com/pditommaso/awesome-pipeline}).
Existing systems can be partitioned into five niches which we will describe below, with highlighted examples of each.

First, workflow management systems like Galaxy~\parencite{Afgan2018} and KNIME~\parencite{wiswedel2007} offer graphical user interfaces for composition and execution of workflows.
The obvious advantage is the shallow learning curve, making such systems accessible for everybody, without the need for programming skills.

Second, with systems like Anduril~\parencite{Cervera2019}, Balsam~\parencite{papka2018}, Hyperloom~\parencite{cima2018hyperloom}, Jug~\parencite{Coelho_2017}, Pwrake~\parencite{Tanaka_2010}, Ruffus~\parencite{Goodstadt2010}, SciPipe~\parencite{Lampa2019}, SCOOP \parencite{SCOOP_XSEDE2014}, and COMPSs~\parencite{Lordan_2013} workflows are specified using a set of classes and functions for generic programming languages like Python, Scala, and others.
Such systems have the advantage that they can be used without a graphical interface (e.g. in a server environment), and that workflows can be straightforwardly managed with version control systems like Git (\url{https://git-scm.com}).

Third, with systems like Nextflow~\parencite{Di_Tommaso_2017}, Snakemake~\parencite{Koester2012}, BioQueue~\parencite{Yao2017}, Bpipe~\parencite{Sadedin2012}, ClusterFlow~\parencite{Ewels2016}, Cylc~\parencite{J_Oliver_2018},~and BigDataScript~\parencite{Cingolani_2014}, workflows are specified using a domain specific language (DSL).
Here, the advantages of the second niche are shared, while adding the additional benefit of improved readability; the DSL provides statements and declarations that specifically model central components of workflow management, thereby obviating superfluous operators or boilerplate code.
For Nextflow and Snakemake, since the DSL is implemented as an extension to a generic programming language (Groovy and Python), access to the full power of the underlying programming language is maintained (e.g. for implementing conditional execution and handling configuration).

Fourth, with systems like Popper~\parencite{Jimenez_2017}, workflow specification happens in a purely declarative way, via configuration file formats like YAML~\parencite{Evans2009-vp}.
These declarative systems share the concision and clarity of the third niche.
In addition, workflow specification can be particularly readable for non-developers.
The caveat of these benefits is that by disallowing imperative or functional programming, these workflow systems can be more restrictive in the processes that can expressed.

Fifth, there are system-independent workflow specification languages like CWL~\parencite{cwl} and WDL~\parencite{voss_full-stack_2017}.
These define a declarative syntax for specifying workflows, which can be parsed and executed by arbitrary executors, e.g. Cromwell (\url{https://cromwell.readthedocs.io}), Toil~\parencite{Vivian_2017}, and Tibanna~\parencite{Lee_2019}.
Similar to the fourth niche, a downside is that imperative or functional programming is not or less integrated into the specification language, thereby limiting the expressive power.
In contrast, a main advantage is that the same workflow definition can be executed on various specialized execution backends, thereby promising scalability to virtually any computing platform.
Another important use case for system-independent languages is that they promote interoperability between other workflow definition languages.
For example, Snakemake workflows can (within limits) be automatically exported to CWL, and Snakemake can make use of CWL tool definitions.
An automatic translation of any CWL workflow definition into a Snakemake workflow is planned as well.

Today, several of the above mentioned approaches support full in silico reproducibility of data analyses (e.g. Galaxy, Nextflow, Snakemake, WDL, CWL), by allowing the definition and scalable execution of each involved step, including deployment of the software stack needed for each step (e.g. via the Conda package manager,~\url{https://docs.conda.io}, Docker,~\url{https://www.docker.com}, or Singularity~\parencite{kurtzer_singularity_2017} containers).

Reproducibility is important to generate trust in scientific results.
However, we argue that a data analysis is only of lasting and sustained value for the authors and the scientific field if a hierarchy of additional interdependent properties is ensured (\autoref{fig:sustainability}).

\begin{figure}
    \centering
	\includegraphics[width=10cm]{sustainability-in-wms.pdf}
	\caption{
		Hierarchy of aspects to consider for sustainable data analysis.
		By supporting the top layer, a workflow management system can promote the center layer, and thereby help to obtain true sustainability.
	}\label{fig:sustainability}
\end{figure}

First, to gain full in silico \emph{reproducibility}, a data analysis has to be \emph{automated}, \emph{scalable} to various computational platforms and levels of parallelism, and \emph{portable} in the sense that it is able to be automatically deployed with all required software in exactly the needed versions.

Second, while being able to reproduce results is a major achievement, \emph{transparency} is equally important: the validity of results can only be fully assessed if the parameters, software, and custom code of each analysis step are fully accessible.
On the level of the code, a data analysis therefore has to be \emph{readable} and well-\emph{documented}.
On the level of the results it must be possible to \emph{trace} parameters, code, and components of the software stack through all involved steps.

Finally, valid results yielded from a reproducible data analysis have greater meaning to the scientific community if the analysis can be reused for other projects.
In practice, this will almost never be a plain reuse, and instead requires~\emph{adaptability} to new circumstances, for example, being able to extend the analysis, replace or modify steps, and adjust parameter choices.
Such adaptability can only be achieved if the data analysis can easily be executed in a different computational environment (e.g. at a different institute or cloud environment), thus it has to be \emph{scalable} and \emph{portable} again (see \autoref{fig:sustainability}).
In addition, it is crucial that the analysis code is as \emph{readable} as possible such that it can be easily modified.

In this work, we show how data analysis sustainability in terms of these aspects is supported by the open source workflow management system Snakemake (\url{https://snakemake.github.io}).
Since its original publication in 2012, Snakemake has seen hundreds of releases and contributions (\autoref{fig:citations}c).
It has gained wide adoption in the scientific community, culminating in, on average, more than five new citations per week, and over 700 citations in total (Fig.~\ref{fig:citations}a,b).
This makes Snakemake one of the most widely used workflow management systems in science.

\begin{figure}
    \centering
	\includegraphics[width=10cm]{citations+development.pdf}
	\caption{
		Citations and development of Snakemake.
		(a) citations by year of the original Snakemake article (note that the year 2020 is still incomplete at the time of writing).
		(b) citations by scientific discipline of the citing article.
		Data source:~\url{https://badge.dimensions.ai/details/id/pub.1018944052}, 2020/09/29.
		(c) cumulative number of git commits over time; Releases are marked as circles.
	}
	\label{fig:citations}
\end{figure}

\section{Results}

We present how Snakemake enables the researcher to conduct data analyses that have all the properties leading to reproducibility, transparency and adaptability. This in turn allows the analysis to become a sustainable resource both for the researcher themselves and the scientific community. 
We structure the results by each of the properties leading to sustainable data analyses (\autoref{fig:sustainability}).

We will thereby introduce relevant features of both the workflow definition language as well as the execution environment.
Several of them are shared with other tools, while others are (at the time of writing) exclusive to Snakemake.
Finally, there are features that other workflow management systems provide while Snakemake does not (or not yet) offer them.
We explicitly refrain from performing a full comparison with other tools, as we believe that such a view will never be unbiased (and quickly outdated), and should instead be provided by review articles or performed by the potential users based on their individual needs.

\subsection{Automation}\label{sec:automation}

The central idea of Snakemake is that workflows are specified through decomposition into steps represented as~\emph{rules~}(\autoref{fig:example}).
Each rule describes how to obtain a set of output files from a set of input files.
This can happen via a shell command, a block of Python code, an external script (Python, R, or Julia), a Jupyter notebook (\url{https://jupyter.org}), or a so-called wrapper (see Sec.~\ref{sec:modularization}).
Depending on the computing platform used and how Snakemake is configured, input and output files are either stored on disk, or in a remote storage (e.g. FTP, Amazon S3, Google Storage, Microsoft Azure Blob Storage, etc.).
Through the use of wildcards, rules can be generic.
For example, see the rule~\lstinline!select_by_country! in Fig.~\ref{fig:example}a (line 20).
It can be applied to generate any output file of the form~\lstinline!results/by-country/{country}.csv!, with~\lstinline!{country}! being a wildcard that can be replaced with any non-empty string.
In shell commands, input and output files, as well additional parameters, are directly accessible by enclosing the respective keywords in curly braces (in case of more than a single item in any of these, access can happen by name or index).

\begin{figure}
    \centering
	\includegraphics[width=12cm]{example-workflow.pdf}
	\caption{
		Example Snakemake workflow. (a) workflow definition; hypothesized knowledge requirement for line readability is color-coded on the left next to the line numbers. (b) directed acyclic graph (DAG) of jobs, representing the automatically derived execution plan from the example workflow; job node colors reflect rule colors in the workflow definition. (c) content of script plot-hist.py referred from rule plot\_histogram. (d) knowledge requirements for readability by statement category (see supplementary \autoref{s-sec:readability}).
		The example workflow downloads data, plots histograms of city populations within a given list of countries, and converts these from SVG to PDF format.
		Note that this is solely meant as a short yet comprehensive demonstration of the Snakemake syntax.
	}
	\label{fig:example}
\end{figure}

When using script integration instead of shell commands, Snakemake automatically inserts an object giving access to all properties of the job (e.g. \lstinline!snakemake.output[0]!, see Fig.
\ref{fig:example}c).
This avoids the presence and repetition of boiler plate code for parsing command line arguments.

By replacing wildcards with concrete values, Snakemake turns any rule into a job which will be executed in order to generate the defined output files.

Dependencies between jobs are implicit, and inferred automatically in the following way.
For each input file of a job, Snakemake determines a rule that can generate it---for example by replacing wildcards again (ambiguity can be resolved by prioritization or constraining wildcards)---yielding another job.
Then, Snakemake goes on recursively for the latter, until all input files of all jobs are either generated by another job or already present in the used storage (e.g., on disk).
Where necessary, it is possible to provide arbitrary Python code to infer input files based on wildcard values or even the contents of output files generated by upstream jobs.

\autoref{fig:example}a illustrates all major design patterns needed to define workflows with Snakemake: workflow configuration (line 1), aggregations (line 5-8), specific (line 33-43) and generic (line 45-53) transformations, target rules (line 3-8), log file definition, software stack definition, as well as shell command, script, and wrapper integration.
Supplementary \autoref{s-sec:design-patterns} presents additional, more exotic patterns that are helpful in certain situations (e.g. conditional execution).

\subsection{Readability}

The workflow definition language of Snakemake is designed to allow maximum readability, which is crucial for transparency and adaptability.
For natural-language readability, the occurrence of known words is important.~For example, the Dale-Chall readability formula derives a score from the fraction of potentially unknown words (that do not occur in a list of common words) among all words in a text~\parencite{chall_readability_1995}.
For workflow definition languages, one has to additionally consider whether punctuation and operator usage is intuitively understandable.
When analyzing the above example workflow (Fig.~\ref{fig:example}a) under these aspects, code statements fall into seven categories (supplementary \autoref{s-sec:readability}).
In addition, for each statement, we can judge whether it

\begin{enumerate}
	\item needs domain knowledge (from the field analyzed in the given workflow),
	\item needs technical knowledge (e.g. about Unix-style shell commands or Python),
	\item needs Snakemake knowledge,
	\item is trivial (i.e., it should be understandable for everybody).
\end{enumerate}

In \autoref{fig:example}, we hypothesize the required knowledge for readability of each code line.
Most statements are understandable with either general education, domain, or technical knowledge.
In particular, only five lines need Snakemake-specific knowledge (\autoref{fig:example}d).
The rationale for each hypothesis can be found in supplementary \autoref{s-sec:readability}.

While this example is obviously not as evolved as a real-world data analysis, the ratio of lines requiring Snakemake knowledge, and lines that are trivial or readable with domain or technical knowledge can be expected to stay roughly the same.
Since Snakemake supports modularization of workflow definitions, it is moreover possible to hide more technical parts of the workflow definition (e.g. helper functions or variables), in order to not distract the reader from understanding the main steps of the data analysis.

Since dependencies between jobs are implicitly encoded via matching filename patterns, we hypothesize that, in general, no specific technical knowledge is necessary to understand the connections between the rules (except for special cases like conditional or dynamically determined dependencies). 
The file-centric description of workflows makes it intuitive to to infer dependencies between steps; when the input of one rule reoccurs as the output of another, their link and order of execution is clear.

\subsubsection{Modularization}\label{sec:modularization}

Specific data analysis steps can become quite complicated, for example, when plotting figures or working around idiosyncrasies of external tools.
It helps readability to modularize these away such that the reader of a workflow only has to inspect them if interested in the specific step.
Some of these steps can be quite specific and unique to the analysis.
Others can be common to the scientific field and utilize widely used tools or libraries in a relatively standard way.
For the latter, Snakemake provides the ability to deposit and use \emph{tool wrappers} in/from a central repository.
In contrast, the former can require custom code, often written in scripting languages like R or Python.
Snakemake allows the user to modularize such steps either into scripts or to craft them interactively by integrating with Jupyter notebooks (\url{https://jupyter.org}).

\paragraph{Script integration.}
Integrating a script works via a special \lstinline!script! directive (see \autoref{fig:example}a, line~42).
The referred script does not need any boilerplate code, and can instead directly use all properties of the job (input files, output files, wildcard values, parameters, etc.), which are automatically inserted as a global \lstinline!snakemake! object before the script is executed (see \autoref{fig:example}c).

\paragraph{Jupyter notebook integration.}
Analogous to script integration, a \lstinline!notebook! directive allows a rule to specify a path to a Jupyter notebook.
Via the command line interface, it is possible to instruct Snakemake to open a Jupyter notebook server for editing a notebook in the context of a specific job derived from the rule that refers to the notebook.
The notebook server can be accessed via a web browser in order to interactively program the notebook until the desired results (e.g. a certain plot or figure) are created as intended.
Upon saving the notebook, Snakemake generalizes it such that other jobs from the same rule can subsequently re-use it automatically without the need for another interactive notebook session.

\paragraph{Tool wrappers.}
Reoccurring tools or libraries can be shared between workflows via Snakemake tool wrappers (see \autoref{fig:example}a, line 52-53).
A central public repository (\url{https://snakemake-wrappers.readthedocs.io}) allows the community to share wrappers with each other.
Each wrapper consists of a Python or R script that either uses libraries of the respective scripting language or calls a shell command.
Moreover, each wrapper provides a Conda environment defining the required software stack, including tool and library versions (see \autoref{sec:portability}).
Often, shell command wrappers contain some additional code that works around various idiosyncrasies of the wrapped tool (e.g. dealing with temporary directories or converting job properties into command line arguments).
A wrapper can be used by simply copying and adapting a provided example rule (e.g. by modifying input and output file paths).
Upon execution, the wrapper code and the Conda environment are downloaded from the repository and automatically deployed to the running system.
In addition to single wrappers, the wrapper repository also offers pre-defined, tested combinations of wrappers that constitute entire sub-workflows for common tasks (called meta-wrappers).
This is particularly useful for combinations of steps that reoccur in many data analyses.
All wrappers are automatically tested to run without errors prior to inclusion in the repository, and upon each committed change.

\subsubsection{Standardized code linting and formatting.}\label{sec:style}

The readability of programming code can be heavily influenced by adhering to common style and best practices \parencite{tysell_sundkvist_code_2017}.
Snakemake provides automatic code formatting (via the tool \lstinline!snakefmt!) of workflows, together with any contained Python code.
In addition, Snakemake has a built in \emph{code linter} that detects code violating best practices (e.g. missing directives, indentation issues, missing environment variables, etc.) and provides suggestions on how to improve the code.

\subsection{Portability}\label{sec:portability}

Being able to deploy a data analysis workflow to an unprepared system depends on: (a) the ability to install the workflow management system itself, and (b) the ability to obtain and use the required software stack for each analysis step.
Snakemake itself is easily deployable via the Conda package manager (\url{https://conda.io}), as a Python package (\url{https://pypi.io}), or a Docker container (\url{https://hub.docker.com/r/snakemake/snakemake}).

The management of software stacks needed for individual rules is directly integrated into Snakemake itself, via two complementary mechanisms.

\paragraph{Conda integration}

For each rule, it is possible to define a software environment that will be automatically deployed via the Conda package manager (via a \lstinline!conda! directive, see \autoref{fig:example}a, line 15).
Each environment is described by a lightweight YAML file used by conda to install constituent software.
While efficiently sharing base libraries like Glib with the underlying operating system, software defined in the environment takes precedence over the same software in the operating system, and is isolated and independent from the same software in other Conda environments.

\paragraph{Container integration}

Instead of defining Conda environments, it is also possible to define a container for each rule (via a \lstinline!container! directive, see \autoref{fig:example}a, line 38).
Upon execution, Snakemake will pull the requested container image and run a job inside that container using Singularity \parencite{kurtzer_singularity_2017}.
The advantage of using containers is that the execution environment can be controlled down to the system libraries, and becomes portable across operating systems, thereby further increasing reproducibility \parencite{gruning_practical_2018}.
Containers already exist in centralized repositories for a wide range of scientific software applications, allowing easy integration info Snakemake workflows. 
The downside of using containers is that generating and modifying container images requires additional effort, as well as storage, since the image has to be uploaded to a container registry. 
The storage needed for containers can be minimized during workflow execution by reusing a common container image across multiple workflow steps, or by using step-specific containers comprised of small layers with step-specific customizations on top of a common shared base layer. 
A sweet spot between containers and Conda can be exploited by combining \lstinline!container! and \lstinline!conda! directives.
In that case, Snakemake will generate the requested Conda environment inside of the container, providing the flexibility of Conda together with the additional reproducibility guarantees of containers.

\subsection{Traceability and documentation}

While processing a workflow, Snakemake tracks input files, output files, parameters, software, and code of each executed job.
After completion, this information can be made available via self-contained, interactive, HTML based reports.
Output files in the workflow can be annotated for automatic inclusion in the report.
These features enable the interactive exploration of results alongside information about their provenance.
Since results are included into the report, their presentation does not depend on availability of server backends, making Snakemake reports easily portable and archivable.
In the future, Snakemake reports will be extended to additionally follow the RO-crate standard, which will make them machine-readable and allow an integration with web services like \url{https://workflowhub.eu}.
An example report summarizing the (minimal) data analysis conducted for this article is included as supplementary file ``report.html''.

\subsection{Scalability}\label{sec:scalability}

Being able to scale a workflow to available computational resources is crucial for reproducing previous results as well as adapting a data analysis to novel research questions or datasets.
Like many other state-of-the-art workflow management systems, Snakemake allows workflow execution to scale to various computational platforms, ranging from single workstations to large compute servers, any common cluster middleware, grid computing, and cloud computing (with native support for Kubernetes, the Google Cloud Life Sciences API, Amazon AWS, TES (\url{https://www.ga4gh.org}), and Microsoft Azure, the latter two in an upcoming release).

Snakemake's design ensures that scaling a workflow to a specific platform should only entail the modification of command line parameters.
The workflow itself can remain untouched.
Via configuration profiles, it is possible to persist and share the command line setup of Snakemake for any computing platform (\url{https://github.com/snakemake-profiles/doc}).


\subsubsection{Job scheduling}
\label{sec:scheduling}

Because of their dependencies, not all jobs in a workflow can be executed at the same time.
Instead, one can imagine partitioning the DAG of jobs into three sections: 
those that are already finished,
those that have already been scheduled but are not finished yet,
and those that have not yet been scheduled (\autoref{fig:scheduling}a).
Let us call the jobs in the latter partition $J^o$, the set of \emph{open} jobs.
Within $J^o$, all jobs that have only incoming edges from the partition of finished jobs (or no incoming edge at all) can be scheduled next.
We call this the set~$J$ of \emph{pending} jobs.
The scheduling problem a workflow manager like Snakemake has to solve is to select the subset $E \subseteq J$ that leads to an efficient execution of the workflow, while not exceeding the given resources like hard drive space, I/O capacity and CPU cores.
Snakemake solves the scheduling problem at the beginning of the workflow execution and whenever a job has finished and new jobs become pending.

Efficiency of execution is evaluated according to three criteria.
First, execution should be as fast as possible.
Second, high-priority jobs should be preferred (Snakemake allows prioritization of jobs via the workflow definition and the command line).
Third, temporary output files should be quickly deleted (Snakemake allows output files to be marked as temporary, which leads to their automatic deletion once all consuming jobs have been finished).
An example is shown in Figure~\ref{fig:scheduling}.

\begin{figure}\centering
\includegraphics[width=5cm]{scheduling.pdf}
\caption{
Snakemake scheduling problem. 
(a) Example workflow DAG.
The greenish area depicts the jobs that are ready for scheduling (because all input files are present) at a given time during the workflow execution.
We assume that the red job at the root generates a temporary file, which may be deleted once all blue jobs are finished.
(b) Suboptimal scheduling solution: two green jobs are scheduled, such that only one blue job can be scheduled and the temporary file generated by the red job has to remain on disk until all blue jobs are finished in a subsequent scheduling step. 
(c) Optimal scheduling solution: the three blue jobs are scheduled, such that the temporary file generated by the red job can be deleted afterwards.}
\label{fig:scheduling}
\end{figure}

\newcommand{\N}{\mathbb{N}}
\newcommand{\cores}{\text{c}}
\newcommand{\fueralle}{\text{ for all }}
\newcommand{\question}[1]{\textbf{({#1})}}

We solve the scheduling problem via a mixed integer linear program (MILP) as follows.
Let~$R$ be the set of resources used in the workflow (e.g., CPU cores and memory).
By default, Snakemake only considers CPU cores which we indicate with $\cores$, i.e., $R = \{\cores\}$.
Let~$F$ be the set of temporary files that are currently present.
%% Constants
We first define constants for each pending job $j \in J$: 
Let $p_j \in \N$ be its priority, let $u_{r,j} \in \N$ be its usage of resource $r \in R$, and let $z_{f,j} \in \{0,1\}$ indicate whether it needs temporary file $f \in F$ as input ($z_{f,j}=1$) or not ($z_{f,j}=0$).
Further, let $U_r$ be the free capacity of resource $r \in R$ (initially what is provided to Snakemake on the command line; later what is left, given resources already used in running jobs).
Let $S_f$ be the size of file $f \in F$, and let $S := \sum_{f\in F}\, S_f$ be be total temporary file size (measured in some reasonable unit, such as MB).


%% Variables
Next, we define indicator variables $x_j \in \{0,1\}$ for each job $j \in J$, indicating whether a job is selected for execution ($1$) or not ($0$).
For each temporary file $f \in F$, we define a variable $\delta_f \in [0,1]$ indicating the fraction of consuming jobs that will be scheduled among all open jobs.
We also call this variable the lifetime fraction of temporary file $f$.
In other words, $\delta_f = 1$ means that all consuming jobs will be completed after this scheduling round has been processed, such that the lifetime of that file is over and it can be deleted.
To indicate the latter, we further define a binary variable $\gamma_f \in \{0,1\}$, with $\gamma_f = 1$ representing the case that $f$ can indeed be deleted, in other words, $\gamma_f = 1 \Leftrightarrow \delta_f = 1$.


\begin{table}
\begin{minipage}[t]{0.54\textwidth}
\textbf{Objective:}
\begin{align}
\text{Maximize}\qquad
    & 2U_\cores \cdot 2S \cdot \sum_{j \in J}\, p_j \cdot x_j
  +   2S \cdot \sum_{j \in J}\, u_{\cores,j} \cdot x_j \qquad \nonumber \\
&{}+   S \cdot \sum_{f \in F}\, S_f \cdot \gamma_f
  +   \sum_{f \in F}\, S_f \cdot \delta_f  \label{objective}
\end{align}
subject to
\begin{align}
x_j & \in \{0,1\} && \fueralle j \in J, \nonumber \\
\gamma_f & \in \{0,1\} && \fueralle f \in F, \nonumber \\ 
\delta_f & \in [0,1] && \fueralle f \in F, \nonumber \\
%%
\sum_{j \in J} x_j \cdot u_{r,j} &\leq U_r && \fueralle r \in R,
    \label{cn:resources}\\
\delta_f & \leq \frac{\sum_{j \in J}\, x_j \cdot z_{f,j}}{\sum_{j \in J^o}\, z_{f,j}} && \fueralle f \in F,
    \label{cn:lifetmp}\\
\gamma_f &\leq \delta_f && \fueralle f \in F.
    \label{cn:deltmp}
\end{align}
\end{minipage}\qquad
%%%%
\begin{minipage}[t]{0.44\textwidth}
\textbf{Variables:}\\[1ex]
binary $(x_j)_{j\in J}$: \\
do we schedule job $j\in J$? \\[1ex]
binary $(\gamma_f)_{f\in F}$: \\
can we delete file $f\in F$? \\[1ex]
continuous $(\delta_f)_{f\in F} \in [0,1]$: \\
lifetime fraction of~$f$; see \eqref{cn:lifetmp} \\[2ex]
%%
\textbf{Parameters:}
\begin{align*}
p_j\in\N     :& \quad \text{priority of job $j\in J$} \\
u_{r,j}\in\N :& \quad \text{$j$'s usage of resource~$r$} \\
z_{f,j}\     :& \quad \text{does job~$j\in J^o$ need file~$f$?} \\
U_r\in\N     :& \quad \text{free capacity of resource~$r$}\\
S_f\in\N     :& \quad \text{size of file~$f$} \\
S\in\N       :& \quad \text{sum of file sizes $\sum\nolimits_f\, S_f$} \\
\end{align*}
\end{minipage}
\caption{Mixed integer linear program for Snakemake's scheduling problem.}
\label{tab:milp}
\end{table}

Then, the scheduling problem can be written as the MILP depicted in Table~\ref{tab:milp}.
The maximization optimizes four criteria, represented by four separate terms in \eqref{objective}.
First, we strive to prefer jobs with high priority.
Second, we aim to maximize the number of used cores, i.e.\ the extent of parallelization.
%\footnote{Snakemake also allows for jobs that use zero cores (i.e.\ $u_{\cores,j} = 0$), hence we add $+1$ to each summand of the second term.}.
%\question{The $+1$ will prefer running more jobs 1-core jobs instead of one job that uses many cores, e.g. consider one 16-core job with value 17 and 16 one-core jobs with total value 32. Why not use $\max\{1, u_{\cores,j}\}$?}
Third, we aim to delete existing temporary files as soon as possible.
Fourth, we try to reduce the lifetime of temporary files that cannot be deleted in this pass.

We consider these four criteria in lexicographical order.
In other words, priority is most important, only upon ties do we consider parallelization.
Given ties while optimizing parallelization, we consider the ability to delete temporary files.
And only given ties when considering the latter, we take the lifetime of all temporary files that cannot be deleted immediately into account.
Technically, this order is enforced by multiplying each criterion sum with a value that is at least as high as the maximum value that the equation right of it can acquire.
Unless the user explicitly requests otherwise, all jobs have the same priority, meaning that in general the optimization problem maximizes the number of used cores while trying to remove as many temporary files as possible.

The constraints \eqref{cn:resources}--\eqref{cn:deltmp} ensure that the variables have the intended meaning and that the computed schedule does not violate resource constraints.
Constraint \eqref{cn:resources} ensures that the available amount $U_r$ of each resource $r \in R$ is not exceeded by the selection.
Constraint \eqref{cn:lifetmp} (together with the fact that $\delta_f$ is being maximized) ensures that $\delta_{f}$ is ineed the lifetime fraction of temporary file $f \in F$.
Note that the sum in the denominator extends over all open jobs, while the numerator only extends over pending jobs.
Constraint \eqref{cn:deltmp} (together with the fact that $\gamma_f$ is being maximized) ensures that $\gamma_f=0$ if and only if $\delta_f < 1$ and hence calculates whether temporary file $f \in F$ can be deleted.

Additional considerations and alternatives, which may be implemented in subsequent releases of Snakemake, are discussed in the Supplement.



\subsubsection{Caching between workflows}\label{sec:caching}

While data analyses usually entail the handling of multiple datasets or samples that are specific to a particular project, they often also rely on retrieval and post-processing of common datasets.
For example, in the life sciences, such datasets include reference genomes and corresponding annotations.
Since such datasets potentially reoccur in many analyses conducted in a lab or at an institute, re-executing the analysis steps for retrieval and post-processing of common datasets as part of individual analyses would waste both disk space and computation time.

Historically, the solution in practice was to compile shared resources with post-processed datasets that could be referred to from the workflow definition.
For example, in the life sciences, this has led to the Illumina iGenomes resource (\url{https://support.illumina.com/sequencing/sequencing\_software/igenome.html}) and the GATK resource bundle (\url{https://gatk.broadinstitute.org/hc/en-us/articles/360035890811-Resource-bundle}).
In addition, in order to provide a more flexible way of selection and retrieval for such shared resources, so-called ``reference management'' systems have been published, like Go Get Data (\url{https://gogetdata.github.io}) and RefGenie (\url{http://refgenie.databio.org}).
Here, the logic for retrieval and post-processing is curated in a set of recipes or scripts, and the resulting resources can be automatically retrieved via command line utilities.
The downside of all these approaches is that the transparency of the data analysis is hampered since the steps taken to obtain the used resources are hidden and less accessible for the reader of the data analysis.

Snakemake provides a new, generic approach to the problem which does not have this downside (see \autoref{fig:caching}).
Leveraging workflow-inherent information, Snakemake can calculate a hash value for each job that unambiguously captures exactly how an output file is generated, prior to actually generating the file.
This hash can be used to store and lookup output files in a central cache (e.g., a folder on the same machine or in a remote storage).
For any output file in a workflow, if the corresponding rule is marked as eligible for caching, Snakemake can obtain the file from the cache if it has been created before in a different workflow or by a different user on the same system, thereby saving computation time, as well as disk space (on local machines, the file can be linked instead of copied).

\begin{figure}
	\centering
	\includegraphics[width=10cm]{caching.pdf}
	\caption{
		Blockchain based between workflow caching scheme of Snakemake.
		If a job is eligible for caching, its code, parameters, raw input files, software environment and the hashes of its dependencies are used to calculate a SHA-256 hash value, under which the output files are stored in a central cache.
		Subsequent runs of the same job (with the same dependencies) in other workflows can skip the execution and directly take the output files from the cache.
	}
	\label{fig:caching}
\end{figure}

The hash value is calculated in the following way.
Let $J$ be the set of jobs of a workflow.
For any job $j \in J$, let $c_j$ denote its code (shell command, script, wrapper, or notebook), let $P_j = \{(k_i, v_i) \mid i=0,\dots,m\}$ be its set of parameters (with key $k_i$ and JSON-encoded value $v_i$), let $F_j$ be its set of input files that are not created by any other job, and let $s_j$ be a string describing the associated software environment (either a container unique resource identifier, a Conda environment definition, or both).
Then, assuming that job $j \in J$ with dependencies $D_j \subset J$ is the job of interest, we can calculate the hash value as $$ h(j) = h'\left( c_j \odot \left(\bigodot_{i=0}^m k_i \odot v_i \right) \odot \left( \bigodot_{f \in F_j} h'(f) \right) \odot s_j \odot \left( \bigodot_{j' \in D_j} h(j') \right) \right) $$ with $h'$ being the SHA-256 \parencite{Handschuh} hash function, $\odot$ being the string concatenation, and $\bigodot$ being the string concatenation of its operands in lexicographic order.

The hash function $h(j)$ comprehensively describes everything that affects the content of the output files of job~\(j\), namely code, parameters, raw input files, the software environment and the input generated by jobs it depends on.
For the latter, we recursively apply the hash function~\(h\) again.
In other words, for each dependency~\(j' \in D_j\) we include a hash value into the hash of job~\(j\), which is in fact the hashing principle behind blockchains used for cryptocurrency \parencite{narayanan_bitcoin_2016}.
The hash is only descriptive if the workflow developer ensures that the cached result is generated in a deterministic way.
For example, downloading from a URL that yields data which may change over time should be avoided.

\subsubsection{Graph partitioning}\label{sec:partitioning}

A data analysis workflow can contain diverse compute jobs, some of which may be long-running, and some which may complete quickly.
When executing a Snakemake workflow in a cluster or cloud setting, by default, every job will be submitted separately to the underlying queuing system.
For short-running jobs, this can result in a considerable overhead, as jobs wait in a queue, and may also incur additional delays or cost when accessing files from remote storage or network file systems.
To minimize such overhead, Snakemake offers the ability to partition the DAG of jobs into subgraphs that will be submitted together, as a single cluster or cloud job.

Partitioning happens by assigning rules to groups (see \autoref{fig:grouping}).
Upon execution, Snakemake determines connected subgraphs with the same assigned group for each job and submits such subgraphs together (as a so called \emph{group job}) instead of submitting each job separately.
For each group, it is in addition possible to define how many connected subgraphs shall be spanned when submitting (one by default).
This way, it is possible to adjust the partition size to the needs of the available computational platform.
The resource usage of a group job is determined by sorting involved jobs topologically, summing resource usage per level and taking the maximum over all levels.

\begin{figure}
    \centering
	\includegraphics[width=15cm]{group-jobs.pdf}
	\caption{Job graph partitioning by assigning rules to groups.
		Two rules of the example workflow (\autoref{fig:example}a) are grouped together, (a) spanning one connected component, (b) spanning two connected components, and (c) spanning five connected components.
		Resulting submitted group jobs are represented as grey boxes.
	}\label{fig:grouping}
\end{figure}

\subsubsection{Streaming}\label{sec:streaming}

Sometimes, intermediate results of a data analysis can be huge, but not important enough to store persistently on disk.
Apart from the option to mark such files as temporary so that Snakemake will automatically delete them once no longer needed, it is also possible to instruct Snakemake to never store them on disk at all by directly streaming their content from the producing job to to the consuming job.
This requires the producing and consuming jobs to run at the same time on the same computing node (then, the output of the producer can be written to a small in-memory buffer; on Unix, this is called a named pipe).
Snakemake ensures this by submitting producer and consumer as a group job (see \autoref{sec:partitioning}).

\section{Conclusion}

While having been almost the holy grail of data analysis workflow management in recent years and being certainly of high importance, reproducibility alone is not enough to sustain the hours of work that scientists invest in crafting data analyses.
Here, we outlined how the interplay of automation, scalability, portability, readability, traceability, and documentation can help to reach beyond reproducibility, making data analyses adaptable and transparent.
Adaptable data analyses can not only be repeated on the same data, but also be modified and extended for new questions or scenarios, thereby greatly increasing their value for both the scientific community and the original authors.
While reproducibility is a necessary property for checking the validity of scientific results, it is not sufficient.
Being able to reproduce exactly the same figure on a different machine tells us that the analysis is robust and valid from a technical perspective.
However, it does not tell anything about the methodological validity (correctness of statistical assumptions, avoidance of overfitting, etc.).
The latter can only be secured by having a transparent yet accessible view on the analysis code.

By analyzing its readability and presenting its modularization, portability, reporting, scheduling, caching, partitioning, and streaming abilities, we have shown how Snakemake supports all these aspects, and thereby provides a comprehensive framework for sustainable data analysis.

\section{Author contributions}
Felix Mölder has designed and implemented the job scheduling mechanism (\autoref{sec:scheduling}; supervised by Johannes Köster and Sven Rahmann) and edited the manuscript.
Kim Philip Jablonski has designed and implemented Jupyter notebook integration (\autoref{sec:modularization}) and edited the manuscript.
Michael Hall and Brice Letcher have designed and implemented automated code formatting (\autoref{sec:style}) and Brice Letcher has edited the manuscript.
Vanessa Sochat has designed and implemented the Google Cloud Life Sciences API execution backend, as well as various improvements to Google storage support (\autoref{sec:scalability}) and edited the manuscript.
Soohyun Lee has designed and implemented the AWS execution backend via integration with Tibanna (\autoref{sec:scalability}).
Sven O.\ Twardziok and Alexander Kanitz have designed and implemented the TES execution backend (\autoref{sec:scalability}).
Andreas Wilm has designed and implemented the Microsoft Azure execution backend (\autoref{sec:scalability}) and edited the manuscript.
Manuel Holtgrewe has designed and implemented benchmarking support (supplementary \autoref{s-sec:design-patterns}).
Jan Forster has designed and implemented meta-wrapper support (\autoref{sec:modularization}).
Christopher Tomkins-Tinch has designed and implemented remote storage support (\autoref{sec:automation}) and edited the manuscript.
Sven Rahmann has edited the manuscript.
Sven Nahnsen has provided the initial idea of using blockchain hashing to fingerprint output files a priori (\autoref{sec:caching}).
Johannes Köster has written the manuscript and implemented all other features that occur in the text but are not explicitly mentioned in above listing.
All authors have read and approved the manuscript.

\section{Acknowledgements}
We are most grateful for the thousands of Snakemake users, their enhancement proposals, bug reports, and efforts to perform sustainable data analyses.
We deeply thank all contributors to the Snakemake, Snakemake-Profile, Snakemake-Workflows, and Snakemake-Wrappers codebases.
This work was supported by the Netherlands Organisation for Scientific Research (NWO) (VENI grant 016.Veni.173.076, Johannes Köster), the German Research Foundation (SFB 876, Johannes Köster and Sven Rahmann), the United States National Science Foundation Graduate Research Fellowship Program (NSF-GRFP) (Grant No. 1745303, Christopher Tomkins-Tinch), and Google LLC (Vanessa Sochat and Johannes Köster).

\printbibliography

\end{document}
